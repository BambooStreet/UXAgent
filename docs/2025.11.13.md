# UXAgent: ììœ¨í˜• ì›¹ ìë™í™” ì—ì´ì „íŠ¸ (v0.3)

ì´ í”„ë¡œì íŠ¸ëŠ” Playwrightë¥¼ í†µí•´ ë¸Œë¼ìš°ì €ë¥¼ ì œì–´í•˜ê³ , 2-Call LLM ì•„í‚¤í…ì²˜ë¥¼ í†µí•´ "ê´€ì°°(Observe) â” ì‚¬ê³ (Think) â” í–‰ë™(Act)" ì‚¬ì´í´ì„ ìˆ˜í–‰í•˜ëŠ” ììœ¨í˜• ì›¹ ì—ì´ì „íŠ¸ì…ë‹ˆë‹¤.

ì´ì»¤ë¨¸ìŠ¤ ì‚¬ì´íŠ¸ì—ì„œ "MSI ë…¸íŠ¸ë¶ êµ¬ë§¤"ë¼ëŠ” ê³ ìˆ˜ì¤€ ëª©í‘œ(Goal)ë¥¼ ë°›ì•„, ìŠ¤ìŠ¤ë¡œ í˜ì´ì§€ë¥¼ íƒìƒ‰í•˜ê³ , í¼ì„ ì…ë ¥í•˜ë©°, ë°œìƒí•˜ëŠ” ì˜¤ë¥˜(ì˜ˆ: ì¹´ë“œ ê²°ì œ ì‹¤íŒ¨)ë¥¼ **ìŠ¤ìŠ¤ë¡œ ì¸ì§€í•˜ê³  ìˆ˜ì •(Self-Correct)**í•˜ì—¬ ìµœì¢… ëª©í‘œë¥¼ ë‹¬ì„±í•˜ë„ë¡ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.

## ğŸš€ í•µì‹¬ ì•„í‚¤í…ì²˜: 2-Call LLM (Strategist + Translator)

ì—ì´ì „íŠ¸ì˜ "ë‡Œ"ëŠ” `think_module.py`ì— êµ¬í˜„ë˜ì–´ ìˆìœ¼ë©°, "ìƒê°"ê³¼ "í–‰ë™"ì„ ëª…í™•íˆ ë¶„ë¦¬í•˜ê¸° ìœ„í•´ LLMì„ 2ë‹¨ê³„ë¡œ í˜¸ì¶œí•©ë‹ˆë‹¤.

### 1. ê´€ì°° (Observe)
* **ëª¨ë“ˆ:** `browser_module.py`
* **í”„ë¡œì„¸ìŠ¤:**
    1.  **ì•Œë¦¼ ìš°ì„  ìŠ¤ìº” (`_extract_alerts`):** í˜ì´ì§€ì˜ `fixed` ë˜ëŠ” `bg-red-` í´ë˜ìŠ¤ë¥¼ ê°€ì§„ `div`ë¥¼ ë¨¼ì € ìŠ¤ìº”í•˜ì—¬, "ì‹œìŠ¤í…œ ì˜¤ë¥˜"ë‚˜ "í•­ëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”" ê°™ì€ ì•Œë¦¼ì„ `[!] CURRENT ALERTS:`ë¡œ ìš”ì•½ë³¸ ìµœìƒë‹¨ì— ì¶”ê°€í•©ë‹ˆë‹¤.
    2.  **HTML ì •ì œ:** `script`, `style` ë“± ë¶ˆí•„ìš”í•œ íƒœê·¸ë¥¼ ì œê±°í•©ë‹ˆë‹¤.
    3.  **ìƒíƒœ ìº¡ì²˜:** `input` íƒœê·¸ì˜ `value` ì†ì„±ì„ ìº¡ì²˜í•˜ì—¬, "ì´ë¦„" í•„ë“œì— "í™ê¸¸ë™"ì´ ì´ë¯¸ ì…ë ¥ë˜ì—ˆëŠ”ì§€ ë“± **í˜„ì¬ ìƒíƒœ**ë¥¼ íŒŒì•…í•©ë‹ˆë‹¤.
    4.  **ê³„ì¸µì  ìš”ì•½:** `max_depth`ê¹Œì§€ DOMì„ ìˆœíšŒí•˜ë©°, ì½˜í…ì¸  íƒœê·¸(`label`, `p`, `h3` ë“±)ì™€ ì»¨í…Œì´ë„ˆ íƒœê·¸(`div`, `a`)ë¥¼ êµ¬ë¶„í•˜ì—¬ 'í•©ì„± í…ìŠ¤íŠ¸' ì˜¤ë¥˜ ì—†ì´ ì‹¤ì œ DOM êµ¬ì¡°ì— ê°€ê¹Œìš´ ìš”ì•½ë³¸ì„ ìƒì„±í•©ë‹ˆë‹¤.

### 2. ì‚¬ê³  (Think) - 1ì°¨ í˜¸ì¶œ: ì „ëµê°€ (Strategist)
* **ëª¨ë“ˆ:** `think_module.py` (Call 1)
* **ì…ë ¥:**
    1.  `observe` ìš”ì•½ë³¸ (ì•Œë¦¼, í¼ `value` í¬í•¨)
    2.  `HIGH_LEVEL_GOAL` (ì˜ˆ: "MSI ë…¸íŠ¸ë¶ êµ¬ë§¤")
    3.  `history` (ì´ì „ ìŠ¤í…ì˜ ì‹¤íŒ¨/ì„±ê³µ ê¸°ë¡)
* **í”„ë¡œì„¸ìŠ¤:**
    * `STRATEGIST_PROMPT`ì— ì •ì˜ëœ "í•µì‹¬ ì‚¬ê³  ì›ì¹™"ì— ë”°ë¼ í–‰ë™í•©ë‹ˆë‹¤.
    * **(ê´€ì°° ê¸°ë°˜)** `history`ì˜ "ìƒê°"ì´ ì•„ë‹Œ, `observe`ì˜ "í˜„ì¬ `value`"ë¥¼ ë³´ê³  ë¹ ì§„ í¼ í•­ëª©ì„ ì°¾ìŠµë‹ˆë‹¤.
    * **(ìê¸° ìˆ˜ì •)** `[!] CURRENT ALERTS:`ê°€ ê´€ì°°ë˜ë©´, [ì´ì „ ê¸°ë¡]ì„ ì°¸ê³ í•˜ì—¬ "ì¹´ë“œ ê²°ì œê°€ ì‹¤íŒ¨í–ˆìœ¼ë‹ˆ ë¬´í†µì¥ì…ê¸ˆì„ ì‹œë„í•œë‹¤"ì™€ ê°™ì´ **ìŠ¤ìŠ¤ë¡œ ê³„íšì„ ìˆ˜ì •**í•©ë‹ˆë‹¤.
* **ì¶œë ¥:** ë‹¤ìŒ í–‰ë™ì— ëŒ€í•œ **'ìì—°ì–´ ê³„íš'** (ì˜ˆ: "í˜„ì¬ 'ì´ë¦„' valueëŠ” ì±„ì›Œì¡Œì§€ë§Œ 'ì—°ë½ì²˜'ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. 'ì—°ë½ì²˜' <label>ì— ê°’ì„ ì…ë ¥í•©ë‹ˆë‹¤.")

### 3. ì‚¬ê³  (Think) - 2ì°¨ í˜¸ì¶œ: ë²ˆì—­ê°€ (Translator)
* **ëª¨ë“ˆ:** `think_module.py` (Call 2)
* **ì…ë ¥:** "ì „ëµê°€"ê°€ ìƒì„±í•œ 'ìì—°ì–´ ê³„íš'
* **í”„ë¡œì„¸ìŠ¤:**
    * `TRANSLATOR_PROMPT`ì˜ ì—„ê²©í•œ ê·œì¹™ì— ë”°ë¼ "ìì—°ì–´"ë¥¼ **`act` í•¨ìˆ˜ê°€ ì´í•´í•  ìˆ˜ ìˆëŠ” ë‹¨ í•˜ë‚˜ì˜ JSON**ìœ¼ë¡œ "ë²ˆì—­"í•©ë‹ˆë‹¤.
    * (ì˜ˆ: "'ì—°ë½ì²˜' <label>ì— ì…ë ¥" â” `{"name": "fill", "params": {"label": "ì—°ë½ì²˜", ...}}`)
* **ì¶œë ¥:** `action` JSON

### 4. í–‰ë™ (Act)
* **ëª¨ë“ˆ:** `browser_module.py`
* **ì…ë ¥:** "ë²ˆì—­ê°€"ê°€ ìƒì„±í•œ `action` JSON
* **í”„ë¡œì„¸ìŠ¤:** `_find_locator`ê°€ `data-testid`, `label`, `text` ë“±ì˜ ìš°ì„ ìˆœìœ„ì— ë”°ë¼ Playwright `locator`ë¥¼ ì°¾ì•„ `.click()` ë˜ëŠ” `.fill()`ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.

### 5. ê¸°ë¡ (Log)
* **ëª¨ë“ˆ:** `main.py`
* **í”„ë¡œì„¸ìŠ¤:** ëª¨ë“  ìŠ¤í…ì˜ `observe` íŒŒì¼ ê²½ë¡œ, `thought`, `action`, `result` (ì„±ê³µ/ì‹¤íŒ¨/ì—ëŸ¬)ë¥¼ `logs/run_YYYYMMDD_HHMMSS.jsonl` íŒŒì¼ì— ì €ì¥í•˜ì—¬ ë””ë²„ê¹…ì„ ë•ìŠµë‹ˆë‹¤.

---

## ğŸ› ï¸ ì£¼ìš” ë¬¸ì œ í•´ê²° ê³¼ì • (ë””ë²„ê¹… ë¡œê·¸)

í˜„ì¬ ì•„í‚¤í…ì²˜ëŠ” ì´ˆê¸° ë²„ì „ì˜ ìˆ˜ë§ì€ ì‹¤íŒ¨ë¥¼ í†µí•´ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.

1.  **ë¬¸ì œ: "í•©ì„± í…ìŠ¤íŠ¸" ì˜¤ë¥˜ (Step 1)**
    * **í˜„ìƒ:** `observe`ê°€ `<a>` íƒœê·¸ ë‚´ì˜ `<h3>`, `<p>` í…ìŠ¤íŠ¸ë¥¼ ëª¨ë‘ í•©ì³ `"MSI...3,200,000ì›"`ì´ë¼ëŠ” 'ê°€ì§œ í…ìŠ¤íŠ¸'ë¥¼ ìƒì„±. LLMì´ ì´ë¥¼ í´ë¦­í•˜ë ¤ë‹¤ íƒ€ì„ì•„ì›ƒ.
    * **í•´ê²°:** `node_to_text` í•¨ìˆ˜ë¥¼ ìˆ˜ì •í•˜ì—¬, 'ì»¨í…Œì´ë„ˆ' íƒœê·¸(div, a)ëŠ” `recursive=False`ë¡œ, 'ì½˜í…ì¸ ' íƒœê·¸(h3, p, label)ëŠ” `recursive=True`ë¡œ í…ìŠ¤íŠ¸ë¥¼ ë‹¤ë¥´ê²Œ ìˆ˜ì§‘í•˜ë„ë¡ ìˆ˜ì •.

2.  **ë¬¸ì œ: í¼(Form) ì •ë³´ ëˆ„ë½ (Step 4~ ë£¨í”„)**
    * **í˜„ìƒ:** `observe_summary.txt`ì— `<h2>ë°°ì†¡ ì •ë³´</h2>` ì œëª©ë§Œ ìˆê³ , `input`ê³¼ `label`ì´ ëª¨ë‘ ëˆ„ë½ë¨.
    * **í•´ê²°:** `êµ¬ë§¤í˜ì´ì§€.html` ë¶„ì„ ê²°ê³¼, í¼ ìš”ì†Œê°€ `depth=10`ì— ìœ„ì¹˜. `main.py`ì—ì„œ `observe` í˜¸ì¶œ ì‹œ `max_depth=8`ì„ `max_depth=12`ë¡œ ìƒí–¥ ì¡°ì •.

3.  **ë¬¸ì œ: "ê³¼ê±°ì˜ ìƒê°"ì— ê°‡í˜ (Step 5~ ë£¨í”„)**
    * **í˜„ìƒ:** LLMì´ Step 4ì—ì„œ "ì´ë¦„, ì—°ë½ì²˜, ì£¼ì†Œë¥¼ ë‹¤ ì±„ì›Œì•¼ì§€"ë¼ê³  *ìƒê°*í•œ ê²ƒì„, Step 5ì—ì„œ "ë‹¤ ì±„ì› ê² ì§€"ë¼ê³  *ì˜¤ì¸*í•¨. `observe`ê°€ `value`ë¥¼ ìº¡ì²˜í•˜ì§€ ì•Šì•„ LLMì´ 'ì´ë¦„' í•„ë“œê°€ ë¹„ì–´ìˆë‹¤ê³  ì°©ê°í•˜ê³  'ì´ë¦„' ì…ë ¥ë§Œ ë°˜ë³µ.
    * **í•´ê²° (2ë‹¨ê³„):**
        1.  **"ëˆˆ"**: `browser_module.py`ì˜ `walk` í•¨ìˆ˜ê°€ `<input>`ì˜ `value` ì†ì„±ì„ ìº¡ì²˜í•˜ë„ë¡ ìˆ˜ì •.
        2.  **"ë‡Œ"**: `STRATEGIST_PROMPT`ì— "ì ˆëŒ€ 'ì´ì „ ìƒê°'ì„ 'ì‚¬ì‹¤'ë¡œ ê°€ì •í•˜ì§€ ë§ê³ , **'í˜„ì¬ ê´€ì°°ëœ `value`'ë¥¼ ê¸°ë°˜ìœ¼ë¡œ íŒë‹¨**í•˜ë¼"ëŠ” **[ê´€ì°° ê¸°ë°˜ íŒë‹¨]** ì›ì¹™ ì¶”ê°€.

4.  **ë¬¸ì œ: "ê²°ì œ ìˆ˜ë‹¨" ì˜¤ì¸ ë° "ì•Œë¦¼" ë¬´ì‹œ (Step 9~ ë£¨í”„)**
    * **í˜„ìƒ:** LLMì´ (1)'ê²°ì œ ìˆ˜ë‹¨' **ì„¹ì…˜ ì œëª©**ì„ í´ë¦­(`label="ê²°ì œ ìˆ˜ë‹¨"`)í•˜ë ¤ë‹¤ íƒ€ì„ì•„ì›ƒ. (2)ì˜µì…˜ì´ ì•ˆ ë³´ì¸ë‹¤ë©° 'ê²°ì œí•˜ê¸°'ë§Œ í´ë¦­. (3)'ì¹´ë“œ ê²°ì œ' ì‹¤íŒ¨ ì‹œ ëœ¨ëŠ” **"ì•Œë¦¼"ì„ `observe`ê°€ ìº¡ì²˜í•˜ì§€ ëª»í•´** ë¬´í•œ ë£¨í”„.
    * **í•´ê²° (2ë‹¨ê³„):**
        1.  **"ëˆˆ"**: `browser_module.py`ì— `_extract_alerts` í—¬í¼ í•¨ìˆ˜ë¥¼ ì¶”ê°€í•˜ì—¬, `bg-red-` ê°™ì€ ì•Œë¦¼ í´ë˜ìŠ¤ë¥¼ `observe` ìš”ì•½ë³¸ **ìµœìƒë‹¨(`[!] CURRENT ALERTS:`)**ì— ê°•ì œë¡œ ì¶”ê°€.
        2.  **"ë‡Œ"**: `STRATEGIST_PROMPT`ì— "ì•Œë¦¼ì´ ê´€ì°°ë˜ë©´ 'ìê¸° ìˆ˜ì •'í•˜ë¼"ëŠ” ê·œì¹™ê³¼, "'ì„¹ì…˜ ì œëª©'ì´ ì•„ë‹Œ **'ì˜µì…˜ label'(ì˜ˆ: ì¹´ë“œ ê°„í¸ê²°ì œ)**ì„ í´ë¦­í•˜ë¼"ëŠ” `[í´ë¦­ ê³„íš]` ê·œì¹™ ì¶”ê°€.

---

## ğŸ—‚ï¸ ìµœì¢… ì½”ë“œ

<details>
<summary><b>ğŸ“„ browser_module.py (ìµœì¢…ë³¸)</b></summary>

```python
from typing import Tuple, Dict, Any, List, Optional
import re

from playwright.sync_api import sync_playwright, Browser, Page
from bs4 import BeautifulSoup, Tag

# --- setup_browser, close_browserëŠ” ë™ì¼ (ìƒëµ) ---
def setup_browser(initial_url: str) -> Tuple[Page, Browser]:
    playwright = sync_playwright().start()
    browser = playwright.chromium.launch(headless=False)
    context = browser.new_context()
    page = context.new_page()
    page.goto(initial_url)
    page.wait_for_load_state("domcontentloaded")
    browser.playwright_instance = playwright  # type: ignore[attr-defined]
    return page, browser

def close_browser(browser: Browser) -> None:
    playwright = getattr(browser, "playwright_instance", None)
    browser.close()
    if playwright is not None:
        playwright.stop()
# --- (ìƒëµ ë) ---

def _pre_process_actionable(soup: BeautifulSoup) -> Dict[Tag, str]:
    actionable_map: Dict[Tag, str] = {}
    aid_counter = 1
    
    selectors = [
        "a[href]", "button", "input", "textarea", "select",
        "label[for]", "[data-testid]", "[role='button']", "[role='link']",
        "[role='tab']", "[role='checkbox']"
    ]
    
    elements_to_process = set()
    for selector in selectors:
        elements_to_process.update(soup.select(selector))

    for el in elements_to_process:
        if not isinstance(el, Tag) or el in actionable_map:
            continue
        ax_id = f"aid-{aid_counter}"
        actionable_map[el] = ax_id
        aid_counter += 1
        
    return actionable_map

def _extract_alerts(soup: BeautifulSoup) -> List[str]:
    alert_lines: List[str] = []
    alerts_found_texts = set()

    alert_selectors = [
        'div[class*="fixed"][class*="bg-red-"]',
        'div[class*="absolute"][class*="bg-red-"]',
        'ol[class*="fixed top-0"] li',
        'ul[class*="fixed top-0"] li',
        'div[data-sonner-toast]'
    ]

    for selector in alert_selectors:
        for alert in soup.select(selector):
            text = " ".join(alert.stripped_strings)
            text = re.sub(r"\s+", " ", text)
            if text and text not in alerts_found_texts:
                alert_lines.append(f"  <alert> {text}")
                alerts_found_texts.add(text)
                
    if alert_lines:
        alert_lines.insert(0, "[!] CURRENT ALERTS:")
        alert_lines.append("---")
        
    return alert_lines

def observe(
    page: Page,
    max_depth: int = 8,
    max_chars: Optional[int] = 4000,
    save_prefix: str = "observe"
) -> tuple[str, str]:
    
    html_content = page.content()
    with open(f"{save_prefix}_raw.html", "w", encoding="utf-8") as f:
        f.write(html_content)

    soup = BeautifulSoup(html_content, "html.parser")

    for tag_name in ["script", "style", "link", "meta", "noscript", "svg", "path"]:
        for t in soup.find_all(tag_name):
            t.decompose()

    with open(f"{save_prefix}_clean.html", "w", encoding="utf-8") as f:
        f.write(soup.prettify())

    body = soup.body or soup
    actionable_map = _pre_process_actionable(body)
    
    lines: List[str] = _extract_alerts(soup)

    interesting_tags = {
        "header", "nav", "main", "section", "article", "footer",
        "div", "ul", "ol", "li",
        "h1", "h2", "h3", "h4", "p", "span",
        "button", "img",
        "input", "textarea", "select", "label"
    }

    def node_to_text(node: Tag) -> str:
        name = node.name
        if name in ("label", "button", "h1", "h2", "h3", "h4", "p", "span", "a"):
            text = " ".join(node.stripped_strings)
        else:
            direct_texts = [
                t.strip()
                for t in node.find_all(string=True, recursive=False)
                if t.strip()
            ]
            text = " ".join(direct_texts)
        
        text = re.sub(r"\s+", " ", text)
        return text[:120]

    def walk(node: Tag, depth: int = 0):
        if depth > max_depth or not isinstance(node, Tag):
            return

        name = node.name
        ax_id = actionable_map.get(node)
        
        if name in interesting_tags or ax_id:
            text_part = node_to_text(node)
            
            if not text_part and name in ('div', 'span', 'li'):
                for child in node.children:
                    walk(child, depth + 1)
                return

            indent = "  " * depth
            extra = ""
            
            if ax_id:
                extra += f" ax-id={ax_id}"
            
            if node.get("href"):
                extra += f" href={node.get('href')}"
            if name == "img" and node.get("alt"):
                extra += f" alt={node.get('alt')}"
            if name == "input":
                if node.get("type"): extra += f" type={node.get('type')}"
                if node.get("id"): extra += f" id={node.get('id')}"
                if node.get("placeholder"): extra += f" placeholder={node.get('placeholder')}"
                if node.get("value"):
                    extra += f" value=\"{node.get('value')}\""
            if name == "label" and node.get("for"):
                extra += f" for={node.get('for')}"
            if node.get("data-testid"):
                extra += f" data-testid={node.get('data-testid')}"

            line = f"{indent}<{name}{extra}> {text_part}".rstrip()
            lines.append(line)

            for child in node.children:
                walk(child, depth + 1)
        
        else:
            for child in node.children:
                walk(child, depth + 1)

    walk(body, 0)
    summary = "\n".join(lines)

    if max_chars is not None and len(summary) > max_chars:
        summary = summary[:max_chars] + "\n... (truncated)"

    summary_file_path = f"{save_prefix}_summary.txt"
    with open(summary_file_path, "w", encoding="utf-8") as f:
        f.write(summary)

    return summary, summary_file_path

def act(page: Page, command: Dict[str, Any]) -> None:
    name = command.get("name")
    params = command.get("params", {}) or {}

    if not name:
        raise ValueError("command.action.name ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.")

    def _find_locator(p: Dict[str, Any]):
        testid = p.get("testid") or p.get("data-testid")
        if testid:
            return page.get_by_test_id(testid)
        label = p.get("label")
        if label:
            return page.get_by_label(label)
        placeholder = p.get("placeholder")
        if placeholder:
            return page.get_by_placeholder(placeholder)
        role = p.get("role")
        role_name = p.get("name_text")
        if role and role_name:
            return page.get_by_role(role, name=role_name)
        text = p.get("text")
        if text:
            return page.get_by_text(text).first
        selector = p.get("selector")
        if selector:
            return page.locator(selector)
        raise ValueError(f"ì ì ˆí•œ Locatorë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {p}")

    if name == "goto":
        url = params.get("url")
        if not url: raise ValueError("goto ì•¡ì…˜ì—ëŠ” 'url'ì´ í•„ìš”í•©ë‹ˆë‹¤.")
        page.goto(url)
        page.wait_for_load_state("domcontentloaded")
    elif name == "click":
        locator = _find_locator(params)
        locator.click()
    elif name == "fill":
        locator = _find_locator(params)
        value = params.get("value", "")
        locator.fill(value)
    elif name == "wait":
        timeout_ms = params.get("timeout", 1000)
        page.wait_for_timeout(timeout_ms)
    elif name == "wait_for_load":
        page.wait_for_load_state("domcontentloaded")
    else:
        raise ValueError(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì•¡ì…˜ì…ë‹ˆë‹¤: {name}")


        import os
import json
from openai import OpenAI
from typing import Dict, Any, List

try:
    client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))
except Exception as e:
    print(f"--- âš ï¸ ê²½ê³ : OpenAI API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. THINK ëª¨ë“ˆì´ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ---")
    print("--- â¡ï¸ í„°ë¯¸ë„ì—ì„œ 'export OPENAI_API_KEY=your_api_key_here'ë¥¼ ì‹¤í–‰í•˜ì„¸ìš”. ---")
    client = None

# --- í”„ë¡¬í”„íŠ¸ 1: ì „ëµê°€ (Strategist) ---
STRATEGIST_PROMPT = """
ë‹¹ì‹ ì€ 'NotePick' ì›¹ì‚¬ì´íŠ¸ì—ì„œ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” AI ì›¹ ìë™í™” ì—ì´ì „íŠ¸ì˜ 'ì „ëµê°€'ì…ë‹ˆë‹¤.
ë‹¹ì‹ ì˜ ì„ë¬´ëŠ” [ê´€ì°° ìš”ì•½ë³¸], [ìµœì¢… ëª©í‘œ], [ì´ì „ ê¸°ë¡]ì„ ë°”íƒ•ìœ¼ë¡œ,
ëª©í‘œ ë‹¬ì„±ì„ ìœ„í•´ **ë‹¤ìŒì— ìˆ˜í–‰í•  í–‰ë™ ê³„íšì„ 'ìì—°ì–´'ë¡œ ì„œìˆ **í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

[í•µì‹¬ ì‚¬ê³  ì›ì¹™]
1.  **ê´€ì°° ê¸°ë°˜ íŒë‹¨ (Observation-Driven):**
    * **ì ˆëŒ€ 'ì´ì „ ìƒê°(History)'ì„ 'ì‚¬ì‹¤'ë¡œ ê°€ì •í•˜ì§€ ë§ˆì„¸ìš”.** (ì˜ˆ: ì´ì „ì— "ì£¼ì†Œê¹Œì§€ ì±„ì›Œì•¼ì§€"ë¼ê³  ìƒê°í–ˆì–´ë„, 'ì´ë¦„'ë§Œ ì±„ì› ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.)
    * **ë°˜ë“œì‹œ "í˜„ì¬ ê´€ì°°(`observe`)"ëœ ë‚´ìš©**ì„ [ìµœì¢… ëª©í‘œ]ì˜ [í•„ìˆ˜ ì •ë³´]ì™€ ë¹„êµí•˜ì„¸ìš”.
    * (ì˜ˆ: `observe`ì—ì„œ `<input ... value="í™ê¸¸ë™">`ì€ í™•ì¸ë˜ì§€ë§Œ, `<label>ì—°ë½ì²˜`ì— í•´ë‹¹í•˜ëŠ” `<input>`ì— `value`ê°€ ì—†ë‹¤ë©´, **"ì•„, 'ì´ë¦„'ì€ ì±„ì›Œì¡Œì§€ë§Œ 'ì—°ë½ì²˜'ê°€ ì•„ì§ ë¹„ì–´ìˆêµ¬ë‚˜"**ë¼ê³  íŒë‹¨í•´ì•¼ í•©ë‹ˆë‹¤.)
2.  **ì „ì²´ ìŠ¤ìº” (Full Scan):**
    * `observe` ìš”ì•½ë³¸ì´ ê¸¸ë”ë¼ë„, **ë°˜ë“œì‹œ ì²˜ìŒë¶€í„° ëê¹Œì§€ ì „ì²´ë¥¼ ìŠ¤ìº”**í•˜ì—¬ ëª©í‘œ(ì˜ˆ: 'ì¹´ë“œ ê°„í¸ê²°ì œ', 'ë¬´í†µì¥ì…ê¸ˆ', 'ê²°ì œí•˜ê¸°')ì™€ ê´€ë ¨ëœ í‚¤ì›Œë“œê°€ ìˆëŠ”ì§€ í™•ì¸í•´ì•¼ í•©ë‹ˆë‹¤.
    * **(ì¤‘ìš”)** 'ë°°ì†¡ ì •ë³´' ì„¹ì…˜ ì•„ë˜ì— 'ê²°ì œ ìˆ˜ë‹¨' ì„¹ì…˜ì´ ìˆëŠ”ì§€ ëê¹Œì§€ í™•ì¸í•˜ì„¸ìš”. "ì •ë³´ê°€ ì—†ë‹¤"ê³  **ì ˆëŒ€ ì„±ê¸‰í•˜ê²Œ ê²°ë¡  ë‚´ë¦¬ì§€ ë§ˆì„¸ìš”.**
3.  **ìˆœì°¨ì  ê³„íš (Sequential Planning):**
    * í¼ ì…ë ¥(ì´ë¦„, ì—°ë½ì²˜, ì£¼ì†Œ)ê³¼ ì˜µì…˜ ì„ íƒ(ê²°ì œ ìˆ˜ë‹¨) ë“± **í˜ì´ì§€ì˜ ëª¨ë“  ë‹¨ê³„ë¥¼ ë¹ ì§ì—†ì´** ìˆœì„œëŒ€ë¡œ ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤.
4.  **ìê¸° ìˆ˜ì • (Self-Correction):**
    * [ì´ì „ ê¸°ë¡]ì˜ 'ì—ëŸ¬'ë¥¼ ì°¸ê³ í•˜ì—¬ ì‹¤íŒ¨í•œ í–‰ë™ì„ ìˆ˜ì •í•˜ì„¸ìš”.
    * **(ì¤‘ìš”)** ë§Œì•½ `observe` ìš”ì•½ë³¸ ìƒë‹¨ì— **`[!] CURRENT ALERTS:`**ê°€ ê´€ì°°ëœë‹¤ë©´, ê·¸ê²ƒì€ ë‹¹ì‹ ì˜ **ì´ì „ í–‰ë™ì´ ì‹¤íŒ¨í–ˆìŒ**ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.
    * (ì˜ˆ: `<alert> ëª¨ë“  í•­ëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”` ë˜ëŠ” `<alert> ì‹œìŠ¤í…œ ì˜¤ë¥˜ë•Œë¬¸ì— ì–´ë µìŠµë‹ˆë‹¤`)
    * ì´ ì•Œë¦¼ ë©”ì‹œì§€ë¥¼ ë¶„ì„í•˜ì—¬ **ì™œ ì‹¤íŒ¨í–ˆëŠ”ì§€ ì¶”ë¡ **í•˜ê³ , **ì ˆëŒ€ ê°™ì€ í–‰ë™ì„ ë°˜ë³µí•˜ì§€ ë§ˆì„¸ìš”.**
    * (ì˜ˆ: 'ì¹´ë“œ ê²°ì œ'ê°€ ì‹¤íŒ¨í–ˆë‹¤ë©´, 'ë¬´í†µì¥ì¥ì…ê¸ˆ')ì„ ì‹œë„í•˜ëŠ” ìƒˆ ê³„íšì„ ì„¸ìš°ì„¸ìš”.
5.  **íœ´ë¦¬ìŠ¤í‹± (Heuristic):**
    * ê²°ì œ ìˆ˜ë‹¨ì²˜ëŸ¼ ì—¬ëŸ¬ ì˜µì…˜ì´ ìˆë‹¤ë©´, **ê°€ì¥ ìœ„ì— ìˆëŠ” ì˜µì…˜**ì„ ë¨¼ì € ì‹œë„í•˜ì„¸ìš”.

[í¼ ì…ë ¥ ê³„íš]
* 'fill' í–‰ë™ì„ ê³„íší•  ë•Œ, `observe` ìš”ì•½ë³¸ì— ë³´ì´ëŠ” `<label>` í…ìŠ¤íŠ¸(ì˜ˆ: "ì´ë¦„")ë¥¼ ëª…ì‹œí•´ì•¼ í•©ë‹ˆë‹¤.
* (ì˜ˆ: "í˜„ì¬ ê´€ì°°ëœ `<input>`ì„ ë³´ë‹ˆ 'ì´ë¦„'ì€ `value`ê°€ ìˆì§€ë§Œ, 'ì—°ë½ì²˜'ëŠ” `value`ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ **'ì—°ë½ì²˜' <label>ì„ ê°€ì§„ í•„ë“œ**ì— '010-1234-5678'ì„ ì…ë ¥í•©ë‹ˆë‹¤.")

**[ì¤‘ìš”] í´ë¦­ ê³„íš (Label / Option)**
* **'ê²°ì œ ìˆ˜ë‹¨'ê³¼ ê°™ì€ 'ì„¹ì…˜ ì œëª©'ì„ í´ë¦­í•˜ë ¤ê³  ì‹œë„í•˜ì§€ ë§ˆì„¸ìš”.**
* 'ì¹´ë“œ ê°„í¸ê²°ì œ', 'ë¬´í†µì¥ì…ê¸ˆ'ì²˜ëŸ¼ `observe` ìš”ì•½ë³¸ì— ë³´ì´ëŠ” **ì‹¤ì œ 'ì˜µì…˜'ì˜ `<label>` í…ìŠ¤íŠ¸**ë¥¼ ëª…ì‹œí•´ì•¼ í•©ë‹ˆë‹¤.
* (ì¢‹ì€ ì˜ˆ): "ì´ì œ 'ê²°ì œ ìˆ˜ë‹¨' ì„¹ì…˜ì—ì„œ, 'íœ´ë¦¬ìŠ¤í‹±' ì›ì¹™ì— ë”°ë¼ ê°€ì¥ ìœ„ì— ìˆëŠ” **'ì¹´ë“œ ê°„í¸ê²°ì œ' <label>**ì„ í´ë¦­í•©ë‹ˆë‹¤."
* (ë‚˜ìœ ì˜ˆ): "ì´ì œ 'ê²°ì œ ìˆ˜ë‹¨' <label>ì„ í´ë¦­í•©ë‹ˆë‹¤."

[ì¶œë ¥]
* ì˜¤ì§ 'í•œê¸€ ìì—°ì–´'ë¡œ ë‹¹ì‹ ì˜ ê³„íšì„ ì„œìˆ í•˜ì„¸ìš”.
"""

# --- í”„ë¡¬í”„íŠ¸ 2: ë²ˆì—­ê°€ (Translator) ---
TRANSLATOR_PROMPT = """
ë‹¹ì‹ ì€ AI ì—ì´ì „íŠ¸ì˜ 'í–‰ë™ ë²ˆì—­ê°€'ì…ë‹ˆë‹¤.
ë‹¹ì‹ ì˜ ì„ë¬´ëŠ” [ì „ëµê°€ì˜ ìƒê°]ì„ `act()` í•¨ìˆ˜ê°€ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” **ë‹¨ í•˜ë‚˜ì˜ 'action' JSON ê°ì²´**ë¡œ 'ë²ˆì—­'í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.
[ê·œì¹™]
1.  [ì „ëµê°€ì˜ ìƒê°]ì„ ì •í™•íˆ ì´í•´í•˜ì—¬, `act()`ê°€ ì•Œì•„ë“¤ì„ ìˆ˜ ìˆëŠ” 'params' í‚¤ë¡œ ë²ˆì—­í•´ì•¼ í•©ë‹ˆë‹¤.
2.  **[ì¤‘ìš”] 'fill' ë²ˆì—­ ê·œì¹™:**
    * ì „ëµê°€ê°€ "'ì´ë¦„' <label>ì„ ê°€ì§„ í•„ë“œ..."ë¼ê³  ë§í•˜ë©´: `{"name": "fill", "params": {"label": "ì´ë¦„", ...}}`
    * **ì ˆëŒ€ `label` í…ìŠ¤íŠ¸(ì˜ˆ: "ì—°ë½ì²˜")ë¥¼ `placeholder` í‚¤ì— ë„£ì§€ ë§ˆì„¸ìš”.**
3.  **ì ˆëŒ€** 'params' ì•ˆì— `ax-id`, `href`, `class` ë“± 'íŒíŠ¸' ì†ì„±ì„ **í‚¤(key)ë¡œ ì‚¬ìš©í•˜ì§€ ë§ˆì„¸ìš”.**
4.  `_find_locator`ê°€ ì´í•´í•˜ëŠ” **7ê°œì˜ ìœ íš¨í•œ í‚¤**(`data-testid`, `label`, `placeholder`, `role`, `name_text`, `text`, `selector`)ë§Œ ì‚¬ìš©í•˜ì„¸ìš”.
[ìœ íš¨í•œ 'params' í‚¤]
1.  `data-testid`
2.  `label` (ì˜ˆ: "ì´ë¦„", "ë¬´í†µì¥ì…ê¸ˆ", "ì¹´ë“œ ê°„í¸ê²°ì œ")
3.  `placeholder`
4.  `role` + `name_text`
5.  `text`
6.  `selector`
[ì‘ì—… ì™„ë£Œ]
-   [ì „ëµê°€ì˜ ìƒê°]ì´ 'ëª©í‘œ ë‹¬ì„±' ë˜ëŠ” 'êµ¬ë§¤ ì™„ë£Œ'ë¥¼ ì˜ë¯¸í•œë‹¤ë©´, `finish` ì•¡ì…˜ì„ ìƒì„±í•˜ì„¸ìš”.
[ì¶œë ¥]
-   **ë‹¤ë¥¸ ë§ì€ ì ˆëŒ€ í•˜ì§€ ë§ê³ , ì˜¤ì§ 'JSON' ê°ì²´ë§Œ ì¶œë ¥í•©ë‹ˆë‹¤.**
-   (ì˜ˆ: `{"name": "click", "params": {"label": "ì¹´ë“œ ê°„í¸ê²°ì œ"}}`)
-   (ì˜ˆ: `{"name": "fill", "params": {"label": "ì´ë¦„", "value": "í™ê¸¸ë™"}}`)
"""

def think(observation: str, goal: str, history: List[Dict[str, str]]) -> Dict[str, Any]:
    if client is None:
        raise ValueError("OpenAI í´ë¼ì´ì–¸íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. API í‚¤ë¥¼ í™•ì¸í•˜ì„¸ìš”.")

    # --- ğŸ¤– [CALL 1: ì „ëµê°€] ìì—°ì–´ 'ìƒê°' ìƒì„± ---
    strategist_messages = [
        {"role": "system", "content": STRATEGIST_PROMPT},
    ]
    if history:
        strategist_messages.append({"role": "user", "content": f"ì´ì „ í–‰ë™ ê¸°ë¡ (ì°¸ê³ ìš©):\n{json.dumps(history, indent=2, ensure_ascii=False)}"})
    
    strategist_prompt = f"""
    [ìµœì¢… ëª©í‘œ]
    {goal}

    [í˜„ì¬ ê´€ì°° (observe_summary.txt)]
    {observation}

    [ë‹¹ì‹ ì˜ ì „ëµ (ìì—°ì–´ ì¶œë ¥)]
    """
    strategist_messages.append({"role": "user", "content": strategist_prompt})

    try:
        response_thought = client.chat.completions.create(
            model="gpt-4o",
            messages=strategist_messages,
            temperature=0.1,
        )
        thought_content = response_thought.choices[0].message.content
        if not thought_content:
            raise ValueError("ì „ëµê°€ LLMì´ ë¹ˆ 'thought'ë¥¼ ë°˜í™˜í–ˆìŠµë‹ˆë‹¤.")
        
        print(f"ğŸ’¡ LLM Thought: {thought_content}") 

    except Exception as e:
        print(f"--- âŒ Think ëª¨ë“ˆ (Call 1: ì „ëµê°€) ì—ëŸ¬ ---")
        print(f"ì—ëŸ¬: {e}")
        return {"thought": f"ì „ëµê°€ LLM ì—ëŸ¬: {e}", "action": {"name": "finish", "params": {"reason": f"Error: {e}"}}}

    # --- ğŸ¤– [CALL 2: ë²ˆì—­ê°€] 'action' JSON ìƒì„± ---
    translator_messages = [
        {"role": "system", "content": TRANSLATOR_PROMPT},
        {"role": "user", "content": f"[ì „ëµê°€ì˜ ìƒê°]\n{thought_content}\n\n[ë²ˆì—­ëœ 'action' JSON ì¶œë ¥]"}
    ]

    try:
        response_action = client.chat.completions.create(
            model="gpt-4o",
            messages=translator_messages,
            response_format={"type": "json_object"},
            temperature=0.0,
        )
        
        action_content = response_action.choices[0].message.content
        if not action_content:
            raise ValueError("ë²ˆì—­ê°€ LLMì´ ë¹ˆ 'action'ì„ ë°˜í™˜í–ˆìŠµë‹ˆë‹¤.")

        parsed_action = json.loads(action_content)
        
        if "name" in parsed_action and "params" in parsed_action:
            return {
                "thought": thought_content,
                "action": parsed_action
            }
        else:
            raise ValueError(f"'action' JSONì— 'name' ë˜ëŠ” 'params' í‚¤ê°€ ì—†ìŠµë‹ˆë‹¤: {action_content}")

    except Exception as e:
        print(f"--- âŒ Think ëª¨ë“ˆ (Call 2: ë²ˆì—­ê°€) ì—ëŸ¬ ---")
        print(f"ì—ëŸ¬: {e}")
        return {"thought": thought_content, "action": {"name": "finish", "params": {"reason": f"Error: {e}"}}}


        import browser_module
import think_module
import time
import json
import os
import datetime
from typing import List, Dict, Any

# --- 1. ì—ì´ì „íŠ¸ì˜ ìµœì¢… ëª©í‘œ ì„¤ì • (ìˆ˜ì •) ---
HIGH_LEVEL_GOAL = """
[ìµœì¢… ëª©í‘œ]
'MSI GT76 Titan DT 9SG' ìƒí’ˆì„ êµ¬ë§¤í•˜ì„¸ìš”.

[í•„ìˆ˜ ì •ë³´]
- ë°°ì†¡ ì •ë³´:
  - ì´ë¦„: í™ê¸¸ë™
  - ì—°ë½ì²˜: 010-1234-5678
  - ì£¼ì†Œ: ì„œìš¸ì‹œ ê°•ë‚¨êµ¬ í…Œí—¤ë€ë¡œ

[ì„±ê³µ ì¡°ê±´]
'êµ¬ë§¤í•´ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤!' ë©”ì‹œì§€ê°€ ë‚˜ì˜¤ëŠ” 'ì£¼ë¬¸ì™„ë£Œ' í˜ì´ì§€ì— ë„ë‹¬í•˜ë©´ ì„±ê³µì…ë‹ˆë‹¤.
"""

MAX_STEPS = 15

def main():
    # --- [ì‹ ê·œ] Logger ì…‹ì—… ---
    run_id = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    log_dir = "logs"
    os.makedirs(log_dir, exist_ok=True)
    log_file_path = os.path.join(log_dir, f"run_{run_id}.jsonl")

    def log_to_file(data: Dict[str, Any]):
        try:
            with open(log_file_path, "a", encoding="utf-8") as f:
                f.write(json.dumps(data, ensure_ascii=False) + "\n")
        except Exception as e:
            print(f"--- âŒ Logger ì—ëŸ¬ ---: {e}")

    print(f"Logging to: {log_file_path}")
    
    log_to_file({
        "type": "run_start",
        "timestamp": datetime.datetime.now().isoformat(),
        "run_id": run_id,
        "goal": HIGH_LEVEL_GOAL
    })
    # --- [ì‹ ê·œ] Logger ì…‹ì—… ì™„ë£Œ ---

    start_url = "[https://note-pick.replit.app/](https://note-pick.replit.app/)"
    page, browser = browser_module.setup_browser(start_url)
    
    history: List[Dict[str, str]] = []
    
    try:
        for step in range(1, MAX_STEPS + 1):
            print(f"\n--- ğŸš€ [Step {step}/{MAX_STEPS}] ---")
            
            obs_summary = ""
            obs_file_path = f"observe_{step}_summary.txt" # ê¸°ë³¸ê°’
            thought = ""
            action_command = {}

            # --- 1. ê´€ì°° (Observe) ---
            print("ğŸ‘€ í˜„ì¬ í˜ì´ì§€ ê´€ì°° ì¤‘...")
            try:
                page.wait_for_load_state("domcontentloaded", timeout=10000) 
                
                # max_depth=12ë¡œ ìƒí–¥ ì¡°ì •
                obs_summary, obs_file_path = browser_module.observe(
                    page, 
                    max_depth=12, 
                    max_chars=None, 
                    save_prefix=f"observe_{step}"
                )
                print(f"ğŸ“„ ê´€ì°° ìš”ì•½ë³¸ ìƒì„± ì™„ë£Œ. ({obs_file_path})")
                
            except Exception as e:
                print(f"--- âŒ ê´€ì°°(Observe) ì‹¤íŒ¨ ---")
                print(f"ì—ëŸ¬: {e}")
                history.append({"role": "system", "content": f"ê´€ì°° ì‹¤íŒ¨: {e}"})
                log_to_file({
                    "type": "step_error", "step": step, "phase": "observe",
                    "timestamp": datetime.datetime.now().isoformat(), "error": str(e)
                })
                time.sleep(2) 
                continue

            # --- 2. ì‚¬ê³  (Think) ---
            print("ğŸ§  ëª©í‘œ ê¸°ë°˜ í–‰ë™ ê²°ì • ì¤‘... (LLM 2-Call)")
            try:
                decision = think_module.think(obs_summary, HIGH_LEVEL_GOAL, history)
                thought = decision.get("thought", "[Thought ì—†ìŒ]")
                action_command = decision.get("action", {})
            except Exception as e:
                print(f"--- âŒ ì‚¬ê³ (Think) ëª¨ë“ˆ ì‹¤íŒ¨ ---")
                print(f"ì—ëŸ¬: {e}")
                log_to_file({
                    "type": "step_error", "step": step, "phase": "think",
                    "timestamp": datetime.datetime.now().isoformat(), "error": str(e),
                    "observation_file": obs_file_path
                })
                break
            
            if not action_command or not action_command.get("name"):
                print("--- âŒ ìœ íš¨í•˜ì§€ ì•Šì€ Action ---")
                break

            # --- 3. í–‰ë™ (Act) ---
            
            if action_command["name"] == "finish":
                print(f"ğŸ‰ [SUCCESS] ì—ì´ì „íŠ¸ê°€ '{action_command.get('params', {}).get('reason')}' ì´ìœ ë¡œ ì‘ì—…ì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤.")
                log_to_file({
                    "type": "step", "step": step, "phase": "act",
                    "timestamp": datetime.datetime.now().isoformat(),
                    "observation_file": obs_file_path,
                    "thought": thought, "action": action_command, "result": "finish"
                })
                break
            
            print(f"ğŸƒâ€â™‚ï¸ ì‹¤í–‰ Action: {json.dumps(action_command, ensure_ascii=False)}")
            try:
                browser_module.act(page, action_command)
                
                log_to_file({
                    "type": "step", "step": step, "phase": "act",
                    "timestamp": datetime.datetime.now().isoformat(),
                    "observation_file": obs_file_path,
                    "thought": thought, "action": action_command, "result": "success"
                })
                
                history.append({"role": "system", "content": f"--- ë‚˜ì˜ ì´ì „ ìƒê° (Step {step}) ---\n{thought}"})
                history.append({"role": "system", "content": f"--- ë‚˜ì˜ ì´ì „ í–‰ë™ (Step {step}) ---\n{json.dumps(action_command, ensure_ascii=False)}"})
                
            except Exception as e:
                print(f"--- âŒ í–‰ë™(Act) ì‹¤íŒ¨ ---")
                print(f"Action: {action_command['name']}, Params: {action_command.get('params')}")
                print(f"ì—ëŸ¬: {e}")
                
                log_to_file({
                    "type": "step", "step": step, "phase": "act",
                    "timestamp": datetime.datetime.now().isoformat(),
                    "observation_file": obs_file_path,
                    "thought": thought, "action": action_command, 
                    "result": "error", "error_message": str(e)
                })
                
                history.append({"role": "system", "content": f"--- í–‰ë™ ì‹¤íŒ¨ (Step {step}) ---\nAction: {action_command['name']}\nError: {e}"})

            time.sleep(1)

    except Exception as e:
        print(f"\n--- âŒ [MAIN LOOP] ì¹˜ëª…ì ì¸ ì—ëŸ¬ ë°œìƒ ---")
        print(f"ì—ëŸ¬: {e}")
        log_to_file({
            "type": "run_error",
            "timestamp": datetime.datetime.now().isoformat(),
            "error": str(e)
        })
    
    finally:
        print(f"\n--- ğŸ [ì¢…ë£Œ] {MAX_STEPS} ìŠ¤í… ë„ë‹¬ ë˜ëŠ” ì‘ì—… ì™„ë£Œ ---")
        print("ìµœì¢… í˜ì´ì§€ì˜ ìŠ¤í¬ë¦°ìƒ·ì„ 'final_screenshot.png'ë¡œ ì €ì¥í•©ë‹ˆë‹¤.")
        page.screenshot(path="final_screenshot.png")
        
        log_to_file({
            "type": "run_end",
            "timestamp": datetime.datetime.now().isoformat()
        })
        
        print("5ì´ˆ í›„ ë¸Œë¼ìš°ì €ë¥¼ ë‹«ìŠµë‹ˆë‹¤.")
        time.sleep(5)
        browser_module.close_browser(browser)

if __name__ == "__main__":
    main()